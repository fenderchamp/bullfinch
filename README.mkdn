# NAME

Bullfinch

# DESCRIPTION

Bullfinch is a worker queue that uses kestrel as a medium for storage.
Bullfinch spins up worker threads that monitor and respond to messages in
kestrel queues.

# NOTE

Bullfinch uses kestrel-client and therefore only speaks Kestrel's
**text protocol**.

# HIGH LEVEL OVERVIEW #                                   +----------+
                                                      /---| Worker A |--+
Bullfinch works like this:                           /    +-----------  |
                                   +---------------+/     +----------+  |
                                /->| Request Queue |----->| Worker B |--+
    +--------+      +---------+/   +---------------+      +----------+  |
    | Client |----->| Kestrel |                                         /
    +--------+      +---------+<   +----------------+                  /
                                \--| Response Queue |<----------------/
                                   +----------------+

Crystal clear, right?

The Client puts an item into a queue (formatted as json) in the form of:

    {
        "response_queue": "name_of_queue_you_will_read_for_response",
        "other": "stuff",
        "whatever": "you want"
    }

The worker and it's thread(s) are configured to watch a particular queue (see
CONFIGURATION).  Each worker will receive an item from the queue (in some sort
of fair, but random, order) by way of it's `handle` method.  This method will
return an Iterator of strings that will be fed into whatever "response_queue"
was specified in the original request. (Each client should probably use a
unique name, "response_" + pid or something) After your worker returns,
bullfinch will confirm the item you handled.  The client can then draw the
items from the response_queue (whatever it is).  How long it will be before
the item(s) show up there depends on what your worker is doing.  That's your
problem. 

The last record will be followed by an EOF like this:

    { "EOF":"EOF" }

Generally speaking, the best idea is for you to DELETE the response queue
after you encounter the above record.  Since it only exists to satisfy the
request you specified.

# CONFIGURATION

Bullfinch can spin up multiple workers, each with multiple thread instances.
To configure workers, use the following config:

    {
        "workers" : [
            {
                "name" : "JDBC Worker",
                "kestrel_host" : "127.0.0.1",
                "kestrel_port" : 2222,
                "worker_class" : "iinteractive.bullfinch.JDBCWorker",
                "worker_count" : 2,
                "subscribe_to" : "test-net-kestrel",
                "timeout" : 10000,
                "options"  : {
                }
            }
        ]
    }

## Required Options ##

### name ###

The name of the worker.  Doesn't have to equate to an actual class or anything
of consequence.  It is totally for logging purposes.

### kestrel_host ###

The host to connect to when talking to kestrel.

### kestrel_port ###

The port to connect to when talking to kestrel.  Defaults to 2222.

### worker_class ###

The fully qualified class name of the class we'll be instantiating for the
worker.

### subscribe_to ###

The name of the kestrel queue from which to draw work items for this worker.

### timeout ###

The timeout that each "get" request will wait for. This prevents bullfinch
from repeatedly banging on kestrel, instead politely waiting for $timeout
milliseconds to see if anything is ready for work in the queue.

## Optional Options ##

### options ###

This element of the configuration is free form.  Whatever you place here is
assumed to be a HashMap (or whatever the hell your language calls it) and is
passed to the worker when it is configured.

### worker_count ###

The number of worker instances to create for this worker.  Defaults to 1.

# WORKERS #

To create a worker you must create a class that implements
`iinteractive.bullfinch.Worker` and has implementations of configure and
handle, like so:

    public class FooWorker implements Worker {

        public FooWorker() {

        }

        public void configure(HashMap<String,Object> config) throws Exception {

            // Do something with the config, like config.get("foo");
        }

        public Iterator<String> handle(HashMap<String,Object> request) throws Exception {

            ArrayList<String> foo = new ArrayList<String>();
            foo.add("{ \"foo\" : \"bar\" }");
            return foo.iterator();
        }
    }

## constructor ##

Your constructor must take **no** arguments.

## configure ##

This method will receive the `HashMap<String,Object>` from the `options` key
in the configuration (per-worker).  Any per-instance things (like database
connections or kitchen sinks or whathaveyou) should be setup here.

## handle ##

This method is invoked each time an item from the queue is received and it is
that instance's turn to handle it.  This method must return an
`Iterator<String>`.  This allows you to either create a list or create your own
`Iterator` implementation that actually iterates over something. ;)

# CONTRIBUTORS

Stevan Little

# AUTHOR

Cory G Watson <cory.watson@iinteractive.com>

# COPYRIGHT AND LICENSE

This software is copyright (c) 2011 by Infinity Interactive.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.